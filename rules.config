block@scope -> statement@stat block@scope?
statement -> interface@interf | enum@enum | def@def | struct@struct | include@inc | dowhile@dowhile SEMICOLON | whileloop@while | conditional@cond | funcdec@func | LBRACE block@scope? RBRACE | forloop@for | jump@jmp SEMICOLON | return@ret SEMICOLON | chain@exp SEMICOLON | assignment@assign SEMICOLON | declaration@dec SEMICOLON | label@label | funccall@call SEMICOLON
def@def -> "defer" statement@exp
include@inc -> SYMBOL("@") "includeC" LPAREN CONST@inc RPAREN
separator -> SEMICOLON | NEWLINE
assignment@assign -> IDENTIFIER@var OPERATOR("=") expression@exp
funccall@call -> IDENTIFIER@func LPAREN argument@args? RPAREN
funcdec@func -> IDENTIFIER@type? IDENTIFIER@name funcarguments@param? LBRACE block@scope? RBRACE
funcsign@func -> IDENTIFIER@type? IDENTIFIER@name funcarguments@param?
funcarguments -> LPAREN argdec@param? RPAREN
argdec@param -> IDENTIFIER@type IDENTIFIER@name COMMA argdec@param | IDENTIFIER@type IDENTIFIER@name
argument@args -> argname? expression@exp COMMA argument@args | argname? expression@exp
argname -> IDENTIFIER COLON
conditional@cond -> "if" condition@cond LBRACE block@scope? RBRACE else@else?
else@else -> "else" LBRACE block@scope? RBRACE | "else" conditional@cond
condition -> LPAREN expression@cond RPAREN | expression@cond
declaration@dec -> IDENTIFIER@type COLON IDENTIFIER@subtype IDENTIFIER@name OPERATOR("=") expression@exp | IDENTIFIER@type IDENTIFIER@name OPERATOR("=") expression@exp | IDENTIFIER@type COLON? IDENTIFIER@subtype? IDENTIFIER@name | IDENTIFIER@type IDENTIFIER@name
jump@jmp -> "goto" IDENTIFIER@jmp
label@label -> IDENTIFIER@name COLON
expression@exp -> "not"@op expression@exp | LPAREN@syn expression@exp RPAREN | math@exp | lambda@func | funccall@exp | chain@exp | CONST@val | variable@var
lambda@func -> LPAREN argdec@param RPAREN LBRACE block@scope? RBRACE
chain@var -> variable@var DOT@op funccall@exp | variable@var DOT@op variable@exp
math@exp -> funccall@var OPERATOR@op expression@exp | CONST@val OPERATOR@op expression@exp | variable@var OPERATOR@op expression@exp
variable@var -> IDENTIFIER@var LBRACKET@op expression@exp RBRACKET | IDENTIFIER@var
forloop@for -> "for" LPAREN declaration@dec SEMICOLON condition@cond SEMICOLON assignment@assign RPAREN LBRACE block@scope? RBRACE
whileloop@while -> "while" condition@cond LBRACE block@scope? RBRACE
dowhile@dowhile -> "do" LBRACE block@scope? RBRACE "while" condition@cond
enum@enum -> "enum" IDENTIFIER@name LBRACE enumcase@enum_case? RBRACE
enumcase@enum_case -> IDENTIFIER@name COMMA enumcase@enum_case? | IDENTIFIER@name
struct@struct -> "struct" IDENTIFIER@name LBRACE decblock@scope? RBRACE | "struct" IDENTIFIER@name COLON IDENTIFIER@parent? LBRACE decblock@scope? RBRACE
decblock@scope -> declaration@dec SEMICOLON decblock@scope? | funcdec@func decblock@scope?
return@ret -> "return" expression@exp
interface@interf -> "interface" IDENTIFIER@name LBRACE intblock@scope? RBRACE
intblock@scope -> declaration@dec SEMICOLON intblock@scope? | funcsign@func SEMICOLON intblock@scope?