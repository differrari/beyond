block@scope -> statement@stat block@scope?
statement -> funcdec@func | forloop | declaration@dec SEMICOLON | assignment@assign SEMICOLON | funccall@call SEMICOLON | conditional@cond | jump@jmp SEMICOLON | label@label
separator -> SEMICOLON | NEWLINE
assignment@assign -> IDENTIFIER@var OPERATOR("=") expression@exp
funccall@call -> IDENTIFIER@func LPAREN argument@args? RPAREN
funcdec@func -> IDENTIFIER@type? IDENTIFIER@name funcarguments@param? LBRACE block@scope? RBRACE
funcarguments -> LPAREN argdec@param? RPAREN
argdec@param -> IDENTIFIER@type IDENTIFIER@name COMMA argdec@param | IDENTIFIER@type IDENTIFIER@name
argument@args -> argname? expression@exp COMMA argument@args | argname? expression@exp
argname -> IDENTIFIER COLON
conditional@cond -> "if" condition@cond LBRACE block@scope? RBRACE
condition -> LPAREN expression@cond RPAREN | expression@cond
declaration@dec -> IDENTIFIER@type IDENTIFIER@name OPERATOR("=") expression@exp
jump@jmp -> "goto" IDENTIFIER@jmp
label@label -> IDENTIFIER@name COLON
expression@exp -> funccall@exp | chain@exp | LPAREN expression@exp RPAREN | math@exp
chain@exp -> variable@var DOT funccall@exp | variable@var DOT IDENTIFIER@exp
math@exp -> CONST@val OPERATOR@op expression@exp | variable@var OPERATOR@op expression@exp | CONST@val | variable@var
variable@var -> IDENTIFIER@var LBRACKET math@exp RBRACKET | IDENTIFIER@var
forloop -> "for" LPAREN declaration@dec SEMICOLON condition@cond SEMICOLON assignment@assign RPAREN LBRACE block@scope? RBRACE
whileloop -> "while" condition@cond LBRACE block@scope? RBRACE
dowhile -> "do" LBRACE block@scope? RBRACE "while" condition@cond